# streamlit_app.py (RU, preloaded, simplified UI)
# -------------------------------------------------------------
# –ê–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Ä–æ–¥–æ—Å–ª–æ–≤–Ω—ã—Ö (–±–µ–∑ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤)
# –î–∞–Ω–Ω—ã–µ –±–µ—Ä—É—Ç—Å—è –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –ø–∞–ø–∫–∏ ./db_lineages (–≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏).
# –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –Ω–∞ —Ä—É—Å—Å–∫–æ–º, –±–µ–∑ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≤ —Å–∞–π–¥–±–∞—Ä–µ.
# -------------------------------------------------------------

from __future__ import annotations

import io
import json
import re
from pathlib import Path
from typing import Dict, List, Set, Tuple

import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
import streamlit as st
from pyvis.network import Network

# ---------------------- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã -----------------------------------------
DATA_DIR = "db_lineages"      # –ø–∞–ø–∫–∞ —Å CSV –≤–Ω—É—Ç—Ä–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
CSV_GLOB = "*.csv"            # –∫–∞–∫–∏–µ —Ñ–∞–π–ª—ã –±—Ä–∞—Ç—å
AUTHOR_COLUMN = "candidate_name"
SUPERVISOR_COLUMNS = [f"supervisors_{i}.name" for i in (1, 2)]

# ---------------------- –û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã -------------------------------
st.set_page_config(page_title="–ê–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏–µ —Ä–æ–¥–æ—Å–ª–æ–≤–Ω—ã–µ", layout="wide")
st.title("üìö –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∞–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏—Ö —Ä–æ–¥–æ—Å–ª–æ–≤–Ω—ã—Ö")
st.caption(
    "–î–∞–Ω–Ω—ã–µ –∑–∞—Ä–∞–Ω–µ–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π (–ø–∞–ø–∫–∞ db_lineages). –í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞—á–∞–ª—å–Ω—ã—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –∏ —Å–æ–∑–¥–∞–π—Ç–µ –¥–µ—Ä–µ–≤—å—è."
)

# ---------------------- –•–µ–ª–ø–µ—Ä—ã -------------------------------------------

def _norm(s: str) -> str:
    return re.sub(r"\s+", " ", s.replace(".", " ").strip().lower())


def _split(full: str) -> Tuple[str, str, str]:
    p = full.split()
    p += ["", "", ""]
    return (p[0], p[1] if len(p) > 1 else "", p[2] if len(p) > 2 else "")


def variants(full: str) -> Set[str]:
    last, first, mid = _split(full.strip())
    fi, mi = first[:1], mid[:1]
    init = fi + mi
    init_dots = ".".join(init) + "." if init else ""
    return {
        v.strip()
        for v in {
            full,
            f"{last} {first} {mid}".strip(),
            f"{last} {init}",
            f"{last} {init_dots}",
            f"{init} {last}",
            f"{init_dots} {last}",
        }
        if v
    }


def build_index(df: pd.DataFrame, supervisor_cols: List[str]) -> Dict[str, Set[int]]:
    idx: Dict[str, Set[int]] = {}
    for col in supervisor_cols:
        if col not in df.columns:
            continue
        for i, raw in df[col].dropna().items():
            for v in variants(str(raw)):
                idx.setdefault(_norm(v), set()).add(i)
    return idx


def rows_for(df: pd.DataFrame, index: Dict[str, Set[int]], name: str) -> pd.DataFrame:
    hits: Set[int] = set()
    for v in variants(name):
        hits.update(index.get(_norm(v), set()))
    return df.loc[list(hits)] if hits else df.iloc[0:0]


def lineage(df: pd.DataFrame, index: Dict[str, Set[int]], root: str) -> tuple[nx.DiGraph, pd.DataFrame]:
    G = nx.DiGraph()
    collected = []
    Q, seen = [root], set()
    while Q:
        cur = Q.pop(0)
        if cur in seen:
            continue
        seen.add(cur)
        rows = rows_for(df, index, cur)
        if not rows.empty:
            collected.append(rows)
        for _, r in rows.iterrows():
            child = str(r.get(AUTHOR_COLUMN, "")).strip()
            if child:
                G.add_edge(cur, child)
                Q.append(child)
    subset = pd.concat(collected, ignore_index=True).drop_duplicates() if collected else df.iloc[0:0]
    return G, subset


def multiline(name: str) -> str:
    return "\n".join(str(name).split())


def slug(s: str) -> str:
    return re.sub(r"[^A-Za-z–ê-–Ø–∞-—è0-9]+", "_", s).strip("_")


# --------- –†–∏—Å–æ–≤–∞–Ω–∏–µ PNG (—É–º–µ–Ω—å—à–∞–µ–º —à—Ä–∏—Ñ—Ç—ã –∏ —É–∑–ª—ã) -----------------------

def _hierarchy_pos(G: nx.DiGraph, root: str):
    from collections import deque
    levels: Dict[int, List[str]] = {}
    q = deque([(root, 0)])
    seen = set()
    while q:
        n, d = q.popleft()
        if n in seen:
            continue
        seen.add(n)
        levels.setdefault(d, []).append(n)
        for c in G.successors(n):
            q.append((c, d + 1))
    pos: Dict[str, tuple[float, float]] = {}
    for depth, nodes in levels.items():
        width = len(nodes)
        for i, n in enumerate(nodes):
            x = (i + 1) / (width + 1)
            y = -depth
            pos[n] = (x, y)
    return pos


def draw_matplotlib(G: nx.DiGraph, root: str) -> plt.Figure:
    if G.number_of_nodes() == 0:
        fig = plt.figure(figsize=(6, 3.5))
        plt.axis("off")
        plt.text(0.5, 0.5, "–ü–æ—Ç–æ–º–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", ha="center", va="center")
        return fig
    try:
        import networkx.drawing.nx_pydot as nx_pydot  # type: ignore
        pos = nx_pydot.graphviz_layout(G, prog="dot")
    except Exception:
        pos = _hierarchy_pos(G, root)
    fig = plt.figure(figsize=(max(6, len(G) * 0.45), 6))
    nx.draw(
        G,
        pos,
        with_labels=True,
        labels={n: multiline(n) for n in G.nodes},
        node_color="#ADD8E6",
        node_size=2000,   # –±—ã–ª–æ 3200 ‚Üí –Ω–µ–º–Ω–æ–≥–æ –º–µ–Ω—å—à–µ
        font_size=7,      # –∑–∞–º–µ—Ç–Ω–æ –º–µ–Ω—å—à–µ —à—Ä–∏—Ñ—Ç
        arrows=True,
    )
    plt.title(f"–ê–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∞—è —Ä–æ–¥–æ—Å–ª–æ–≤–Ω–∞—è ‚Äì {root}", fontsize=10)
    plt.tight_layout()
    return fig


# --------- –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è HTML-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è (—É–º–µ–Ω—å—à–∞–µ–º —à—Ä–∏—Ñ—Ç—ã) -----------

def build_pyvis_html(G: nx.DiGraph, root: str) -> str:
    net = Network(height="1000px", width="100%", directed=True, bgcolor="#ffffff")
    net.toggle_physics(True)

    for n in G.nodes:
        net.add_node(n, label=multiline(n), title=str(n), shape="box", color="#ADD8E6")
    for u, v in G.edges:
        net.add_edge(u, v, arrows="to")

    vis_opts = {
        "nodes": {"font": {"size": 12}},  # —à—Ä–∏—Ñ—Ç –ø–æ–º–µ–Ω—å—à–µ
        "layout": {"hierarchical": {"direction": "UD", "sortMethod": "directed"}},
        "interaction": {"hover": True},
        "physics": {
            "hierarchicalRepulsion": {
                "nodeDistance": 140,
                "springLength": 160,
                "springConstant": 0.01,
            },
            "solver": "hierarchicalRepulsion",
            "stabilization": {"iterations": 200},
            "minVelocity": 0.1,
        },
    }
    net.set_options(json.dumps(vis_opts))

    try:
        html = net.generate_html()  # type: ignore[attr-defined]
    except Exception:
        tmp = Path("_tmp.html")
        net.save_graph(str(tmp))
        html = tmp.read_text(encoding="utf-8")
        try:
            tmp.unlink()
        except Exception:
            pass
    return html


# ---------------------- –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö ----------------------------------
@st.cache_data(show_spinner=False)
def load_data() -> pd.DataFrame:
    base = Path(DATA_DIR).expanduser().resolve()
    files = sorted(base.glob(CSV_GLOB))
    if not files:
        raise FileNotFoundError(f"–í {base} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ CSV –ø–æ –º–∞—Å–∫–µ '{CSV_GLOB}'")

    # –ø—Ä–æ—Å—Ç–∞—è –∞–≤—Ç–æ‚Äë–¥–µ—Ç–µ–∫—Ü–∏—è —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è –ø–æ –ø–µ—Ä–≤–æ–º—É —Ñ–∞–π–ª—É
    try:
        sample = pd.read_csv(files[0], nrows=5, dtype=str)
        sep = ";" if sample.shape[1] == 1 else ","
    except Exception:
        sep = ","

    frames = [pd.read_csv(f, dtype=str, keep_default_na=False, sep=sep) for f in files]
    return pd.concat(frames, ignore_index=True)


# ====================== –ò–ù–¢–ï–†–§–ï–ô–° (–±–µ–∑ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ —Å–∞–π–¥–±–∞—Ä–∞) ============
try:
    df = load_data()
except Exception as e:
    st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö: {e}")
    st.stop()

# –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏
missing = [c for c in [AUTHOR_COLUMN, *SUPERVISOR_COLUMNS] if c not in df.columns]
if missing:
    st.error("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω—É–∂–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏: " + ", ".join(f"`{c}`" for c in missing))
    st.stop()

# –ò–Ω–¥–µ–∫—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º
idx = build_index(df, SUPERVISOR_COLUMNS)

# –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –¥–ª—è –≤—ã–±–æ—Ä–∞
all_supervisor_names: Set[str] = set()
for col in SUPERVISOR_COLUMNS:
    all_supervisor_names.update({v for v in df[col].dropna().astype(str).unique() if v})

st.subheader("–í—ã–±–æ—Ä –Ω–∞—É—á–Ω—ã—Ö —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–µ—Ä–µ–≤—å–µ–≤")
roots = st.multiselect(
    "–í—ã–±–µ—Ä–∏—Ç–µ –∏–º–µ–Ω–∞ –∏–∑ –±–∞–∑—ã",
    options=sorted(all_supervisor_names),
    default=[],  # –ù–ò–ß–ï–ì–û –Ω–µ –≤—ã–±—Ä–∞–Ω–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    help="–°–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –∏–∑ —Å—Ç–æ–ª–±—Ü–æ–≤ —Å —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º–∏",
)
manual = st.text_area("–ò–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ –∏–º–µ–Ω–∞ –≤—Ä—É—á–Ω—É—é –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –§–∞–º–∏–ª–∏—è –ò–º—è –û—Ç—á–µ—Å—Ç–≤–æ (–ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ —Å—Ç—Ä–æ–∫—É)", height=120)
manual_list = [r.strip() for r in manual.splitlines() if r.strip()]
roots = list(dict.fromkeys([*roots, *manual_list]))  # —É–±—Ä–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã, —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫

build = st.button("–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –¥–µ—Ä–µ–≤—å—è", type="primary")
export_md_outline = st.checkbox("–¢–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ (.md)", value=False)

if build:
    if not roots:
        st.warning("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–º—è —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è.")
        st.stop()

    all_zip_buf = io.BytesIO()
    zf = None
    try:
        import zipfile
        zf = zipfile.ZipFile(all_zip_buf, mode="w", compression=zipfile.ZIP_DEFLATED)
    except Exception:
        pass

    for root in roots:
        st.markdown("---")
        st.subheader(f"‚ñ∂ {root}")
        G, subset = lineage(df, idx, root)

        if G.number_of_edges() == 0:
            st.info("–ü–æ—Ç–æ–º–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ –∏–º–µ–Ω–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
            continue

        # PNG (–º–∏–Ω–∏–∞—Ç—é—Ä–∞) + HTML (—à–∏—Ä–æ–∫–∏–π)
        fig = draw_matplotlib(G, root)
        png_buf = io.BytesIO()
        fig.savefig(png_buf, format="png", dpi=300, bbox_inches="tight")
        png_bytes = png_buf.getvalue()

        st.image(png_bytes, caption="–ú–∏–Ω–∏–∞—Ç—é—Ä–∞ PNG", width=220)
        
        html = build_pyvis_html(G, root)
        st.components.v1.html(html, height=1000, scrolling=True)
        st.markdown(
            f'<iframe srcdoc="{html.replace(\'"\', \'&quot;\')}" style="width:100%; height:1000px; border:none;"></iframe>',
            unsafe_allow_html=True
        )
        html_bytes = html.encode("utf-8")

        # CSV —Å –≤—ã–±–æ—Ä–∫–æ–π
        csv_bytes = subset.to_csv(index=False, encoding="utf-8-sig").encode("utf-8-sig")

        # Markdown‚Äë–æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ (–ø–æ –∂–µ–ª–∞–Ω–∏—é)
        md_bytes = None
        if export_md_outline:
            out_lines: List[str] = []
            def walk(n: str, d: int = 0):
                out_lines.append(f"{'  ' * d}- {n}")
                for c in G.successors(n):
                    walk(c, d + 1)
            walk(root)
            md_bytes = ("\n".join(out_lines)).encode("utf-8")

        s = slug(root)
        c1, c2, c3, c4 = st.columns(4)
        with c1:
            st.download_button("–°–∫–∞—á–∞—Ç—å PNG", data=png_bytes, file_name=f"{s}.png", mime="image/png")
        with c2:
            st.download_button("–°–∫–∞—á–∞—Ç—å HTML", data=html_bytes, file_name=f"{s}.html", mime="text/html")
        with c3:
            st.download_button("–°–∫–∞—á–∞—Ç—å –≤—ã–±–æ—Ä–∫—É CSV", data=csv_bytes, file_name=f"{s}.sampling.csv", mime="text/csv")
        with c4:
            if md_bytes is not None:
                st.download_button("–°–∫–∞—á–∞—Ç—å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ .md", data=md_bytes, file_name=f"{s}.xmind.md", mime="text/markdown")
            else:
                st.empty()

        if zf is not None:
            zf.writestr(f"{s}.png", png_bytes)
            zf.writestr(f"{s}.html", html_bytes)
            zf.writestr(f"{s}.sampling.csv", csv_bytes)
            if md_bytes is not None:
                zf.writestr(f"{s}.xmind.md", md_bytes)

    if zf is not None:
        try:
            zf.close()
            if all_zip_buf.getbuffer().nbytes > 0:
                st.download_button(
                    label="‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å –≤—Å—ë –∞—Ä—Ö–∏–≤–æ–º (ZIP)",
                    data=all_zip_buf.getvalue(),
                    file_name="lineages_export.zip",
                    mime="application/zip",
                )
        except Exception:
            pass
else:
    st.info("–í—ã–±–µ—Ä–∏—Ç–µ –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ –∏–º–µ–Ω–∞ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –∏ –Ω–∞–∂–º–∏—Ç–µ ‚Äò–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –¥–µ—Ä–µ–≤—å—è‚Äô.")

